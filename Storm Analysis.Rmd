---
title: "Storm Analysis: Weather Events That Affect Human Health and the Economy"
output: html_document
---
    Title: Your document should have a title that briefly summarizes your data analysis



###Synopsis
    
    
	•	Synopsis: Immediately after the title, there should be a synopsis which describes and summarizes your analysis in at most 10 complete sentences.

###Data Processing

	•	There should be a section titled Data Processing which describes (in words and code) how the data were loaded into R and processed for analysis. In particular, your analysis must start from the raw CSV file containing the data. You cannot do any preprocessing outside the document. If preprocessing is time-consuming you may consider using the cache = TRUE option for certain code chunks.


I begin by downloading the dataset, reading into R, and giving it the name "StormData". 
```{r}
library(dplyr) ; library(data.table)
```



```{r, cache=TRUE}
if(!file.exists("./data/")){dir.create("./data/")}
url_data <- "https://d396qusza40orc.cloudfront.net/repdata/data/StormData.csv.bz2"
download.file(url_data, destfile="./data/StormData.csv.bz2", method="curl")
StormData <- data.table(read.csv(bzfile("./data/StormData.csv.bz2")))
```
<br>

####Data Cleaning

This data is a bit of a mess. There are 37 variables in the Storm Data, most of those are unnecessary for this analysis. The most important variables are "EVTYPE"" which indicates the type of storm event, "FATALITIES" and "INJURIES" which are self explanatory, and "PROPDMG", "CROPDMG", "PROPDMGEXP" and "CROPDMGEXP" which document property and crop damage. 

The first step is to eliminate a bunch of these unnecessary variables.
```{r}
names(StormData)
```
```{r, cache=TRUE}
StormData <- select(StormData, c(STATE__:EVTYPE, LENGTH:CROPDMGEXP, REFNUM))
```
This cuts it down to a more manageable 19 variables. 

```{r}
names(StormData)
```

<br>

**EVTYPE**

The EVTYPE variable is troubling. It documents the type of storm event but the named events are unwieldy to put it mildly. There are variations on spelling, variation in the use of upper and lower case, typos, events that are abbreviated like TSTM, and events that should be the same but are not like Thunderstorm, THUNDERSTORM, TSTM WIND and THUNDERSTORMWIND. With all these variations there are 935 different factors

To start with I'll put everything in all caps, just eliminating lower case spelling cuts out 37 levels.
```{r, cache=TRUE}
StormData$EVTYPE <- toupper(StormData$EVTYPE)
```
There's also a list of 76 events that contain the word "SUMMARY" for example "SUMMARY AUGUST 11" The person who entered these clearly didn't know what they were doing, so I'm eliminating them. I'm also going to convert and simplify all related event types. For example events that are similar to THUNDERSTORM, e.g. TSTM, THUNDERSTORM WIND G50, etc..., will become one event type "THUNDERSTORM".

```{r, cache=TRUE}
StormData$EVTYPE <- as.character(StormData$EVTYPE)

StormData <- StormData[!grepl("SUMMARY", StormData$EVTYPE)]

StormData$EVTYPE[grepl("THU", StormData$EVTYPE) | grepl("TSTM", StormData$EVTYPE)] <- "THUNDERSTORM"

StormData$EVTYPE[grepl("SNOW", StormData$EVTYPE) ] <- "SNOW"

StormData$EVTYPE[grepl("FLOOD", StormData$EVTYPE) ] <- "FLOOD"

StormData$EVTYPE[grepl("VOLCANIC", StormData$EVTYPE) ] <- "VOLCANIC"

StormData$EVTYPE[grepl("TORN", StormData$EVTYPE) ] <- "TORNADO"

StormData$EVTYPE[grepl("LIGHTN", StormData$EVTYPE) ] <- "LIGHTNING"

StormData$EVTYPE[grepl("RAIN", StormData$EVTYPE) ] <- "RAIN"

StormData$EVTYPE[grepl("FIRE", StormData$EVTYPE) ] <- "FIRE"

StormData$EVTYPE[grepl("TORN", StormData$EVTYPE) ] <- "TORNADO"

StormData$EVTYPE[grepl("HURRIC", StormData$EVTYPE) ] <- "HURRICANE"

StormData$EVTYPE[grepl("HAIL", StormData$EVTYPE) ] <- "HAIL"

StormData$EVTYPE[grepl("BLIZZARD", StormData$EVTYPE) ] <- "BLIZZARD"

StormData$EVTYPE[grepl("WINT", StormData$EVTYPE) ] <- "WINTER STORM"

StormData$EVTYPE[grepl("TROPICAL STORM", StormData$EVTYPE) ] <- "TROPICAL STORM"

StormData$EVTYPE[grepl("TROPICAL", StormData$EVTYPE) ] <- "TROPICAL STORM"

StormData$EVTYPE[grepl("ICE", StormData$EVTYPE) ] <- "ICE"

StormData$EVTYPE[grepl("FLOOD", StormData$EVTYPE) | grepl("FLDG", StormData$EVTYPE)] <- "FLOOD"

StormData$EVTYPE[grepl("MICROBURST", StormData$EVTYPE) ] <- "MICROBURST"

StormData$EVTYPE[grepl("HAIL", StormData$EVTYPE) ] <- "HAIL"

StormData$EVTYPE[grepl("WIND", StormData$EVTYPE) ] <- "WIND"

StormData$EVTYPE[grepl("HAIL", StormData$EVTYPE) ] <- "HAIL"

StormData$EVTYPE[grepl("WATERSP", StormData$EVTYPE) ] <- "WATERSPOUT"

StormData$EVTYPE[grepl("COOL", StormData$EVTYPE) | grepl("COLD", StormData$EVTYPE)] <- "COLD"

StormData$EVTYPE[grepl("HOT", StormData$EVTYPE) | grepl("WARM", StormData$EVTYPE) | grepl("HEAT", StormData$EVTYPE) | grepl("HIGH TEMP", StormData$EVTYPE)] <- "HEAT"

StormData$EVTYPE[grepl("HEAVY PR", StormData$EVTYPE) | grepl("HEAVY SH", StormData$EVTYPE)] <- "THUNDERSTORM"

StormData$EVTYPE[grepl("FREEZ", StormData$EVTYPE) ] <- "FREEZE"

StormData$EVTYPE[grepl("DUST", StormData$EVTYPE) ] <- "DUST"

StormData$EVTYPE[grepl("MUD", StormData$EVTYPE) ] <- "MUD SLIDE"

StormData$EVTYPE[grepl("STREAM", StormData$EVTYPE) ] <- "STREAM FLOOD"

StormData$EVTYPE[grepl("DRY", StormData$EVTYPE) ] <- "DRY"

StormData$EVTYPE[grepl("FUNNEL", StormData$EVTYPE) ] <- "FUNNEL CLOUD"

StormData$EVTYPE[grepl("WND", StormData$EVTYPE) ] <- "WIND"

StormData$EVTYPE[grepl("DAM", StormData$EVTYPE) ] <- "DAM FAILURE"

StormData$EVTYPE[grepl("RIP CURRENT", StormData$EVTYPE) ] <- "RIP CURRENT"

StormData$EVTYPE[grepl("HIGH SURF", StormData$EVTYPE) | grepl("HEAVY SURF", StormData$EVTYPE) | grepl("ROUGH SURF", StormData$EVTYPE)] <- "HEAVY SURF"

StormData$EVTYPE[grepl("STORM SURGE", StormData$EVTYPE) ] <- "STORM SURGE"

StormData$EVTYPE[grepl("AVALANC", StormData$EVTYPE) ] <- "AVALANCHE"


StormData$EVTYPE <- as.factor(as.character(StormData$EVTYPE))
StormLevels <- levels(StormData$EVTYPE)

```


<br>
Even after all that conversion there are still 134 different types of weather events, but the most severe ones should be aggregated into a few names key weather event types. 
```{r}
length(levels(StormData$EVTYPE))
```


<br>
 
To study the impact of storms on human health this analysis will look for storms that impact human health and storms that don't. 

The variables that indicate health impact are:
 
  - "FATALITIES" 
  - "INJURIES" 

<br>
To study the impact of storms on the economy this analysis will look for storms that damage property and storms that don't. 

The variables that indicate economic impact are:
 
  - "PROPDMG"    
  - "CROPDMG"   
  
Both "PROPDMG" and "CROPDMG" give dollar values of property or crop damage. There are two other variables,  "PROPDMGEXP" and "CROPDMGEXP", that give values indicating the order of magnitude of the damage, for example 'h' or 'H' indicates hundreds of dollars. Combining the two sets of values indicates how much damage there was. For example, a 1 in the PROPDMG column, plus "H" in the PROPDMGEXP column indicates a total of $100 of property damage. 2.5 plus "K" indicates $2,500 of damage. A full key of PROPDMGEXP values is included at the bottom of this document.

<br>

What I'm looking for is weather events that have a disproportionate impact on the economy or on health. As a hypothetical example, there may be a lot of thunderstorms with a lot of damage but each thunderstorm may have a low probability of injuring people or damaging property. In contrast, there may be many fewer tornadoes but each tornado may be disproportionately destructive. 

####Injuries and Fatalities

There were 21929 storm events that resulted in at least one injury or fatality
```{r}
sum(StormData$INJURIES > 0 | StormData$FATALITIES > 0)
```

```{r, cache=TRUE}
library(dplyr)

StormInjuriesFatalities <- filter(StormData, StormData$INJURIES > 0 | StormData$FATALITIES > 0)
dim(StormInjuriesFatalities)
```

I'm creating a new variable called WFI, or Weighted Fatalities and Injuries. This variable will combine injuries and fatalities into one variable and give more weight to fatalities. The formula is Fatalities * 10 + Injuries. 

```{r}
StormInjuriesFatalities$WFI <- sapply(StormInjuriesFatalities$FATALITIES, function(x) x*10) + StormInjuriesFatalities$INJURIES
```

Using tapply I'll aggregate the WFI variable by each storm event type.

```{r}
WFIbyEVTYPE <- tapply(StormInjuriesFatalities$WFI, StormInjuriesFatalities$EVTYPE, sum, na.rm=TRUE)
WFIbyEVTYPE <- data.table(EVTYPE = names(WFIbyEVTYPE), WFI = WFIbyEVTYPE)
```

There are a lot of weather event types that don't have any injuries or fatalities. This step eliminates all NA's in WFIbyEVTYPE
```{r}
WFIbyEVTYPE <- WFIbyEVTYPE[!is.na(WFIbyEVTYPE$WFI)]
```


####Property and Crop Damage

```{r}
sum(StormData$CROPDMG > 0 | StormData$PROPDMG >0 )
range(StormData$CROPDMG[StormData$CROPDMG > 0])
range(StormData$PROPDMG[StormData$PROPDMG > 0])
```


###Results
	•	There should be a section titled Results in which your results are presented.
```{r}

```


```{r}

```

Your data analysis must address the following questions:
  1	Across the United States, which types of events (as indicated in the EVTYPE variable) 
    are most harmful with respect to population health?
  2	Across the United States, which types of events have the greatest economic consequences?
Consider writing your report as if it were to be read by a government or municipal manager who 
might be responsible for preparing for severe weather events and will need to prioritize resources 
for different types of events. However, there is no need to make any specific recommendations in your report




####**Document Layout**

	•	You may have other sections in your analysis, but Data Processing and Results are required.
	•	The analysis document must have at least one figure containing a plot.
	•	Your analyis must have no more than three figures. Figures may have multiple plots in them (i.e. panel plots), but there cannot be more than three figures total.
	•	You must show all your code for the work in your analysis document. This may make the document a bit verbose, but that is okay. In general, you should ensure that echo = TRUE for every code chunk (this is the default setting in knitr).
	
	
	
	
	
###Footnote

####These are possible values of CROPDMGEXP and PROPDMGEXP:

H,h,K,k,M,m,B,b,+,-,?,0,1,2,3,4,5,6,7,8, and blank-character

H,h = hundreds = 100

K,k = kilos = thousands = 1,000

M,m = millions = 1,000,000

B,b = billions = 1,000,000,000

(+) = 1

(-) = 0

(?) = 0

black/empty character = 0

numeric 0..8 = 10
	
	
	
	
	
	