---
title: "Storm Analysis: Weather Events That Affect Human Health and the Economy"
output: html_document
---
    Title: Your document should have a title that briefly summarizes your data analysis



###Synopsis
    
    
	•	Synopsis: Immediately after the title, there should be a synopsis which describes and summarizes your analysis in at most 10 complete sentences.

###Data Processing

	•	There should be a section titled Data Processing which describes (in words and code) how the data were loaded into R and processed for analysis. In particular, your analysis must start from the raw CSV file containing the data. You cannot do any preprocessing outside the document. If preprocessing is time-consuming you may consider using the cache = TRUE option for certain code chunks.


I begin by downloading the dataset, reading into R, and giving it the name "StormData". 
```{r}
library(dplyr) ; library(data.table) ; library(ggplot2); options(width=60)
```



```{r, cache=TRUE}
if(!file.exists("./data/StormData.csv.bz2")){
        if(!file.exists("./data/")){dir.create("./data/")}
        url_data <- "https://d396qusza40orc.cloudfront.net/repdata/data/StormData.csv.bz2"
        download.file(url_data, destfile="./data/StormData.csv.bz2", method="curl")
}
```
```{r, cache=TRUE}

StormData <- data.table(read.csv(bzfile("./data/StormData.csv.bz2")))

```

<br>

####Data Cleaning

This data is a bit of a mess. There are 37 variables in the Storm Data, most of those are unnecessary for this analysis. The most important variables are "EVTYPE"" which indicates the type of storm event, "FATALITIES" and "INJURIES" which are self explanatory, and "PROPDMG", "CROPDMG", "PROPDMGEXP" and "CROPDMGEXP" which document property and crop damage. 

The first step is to eliminate a bunch of these unnecessary variables.
```{r}
names(StormData)
```
```{r, cache=TRUE}
StormData <- select(StormData, c(STATE__:EVTYPE, LENGTH:CROPDMGEXP, REFNUM))
```
This cuts it down to a more manageable 19 variables. 

```{r}
names(StormData)
```

<br>

**EVTYPE**

The EVTYPE variable is troubling. It documents the type of storm event but the named events are unwieldy to put it mildly. There are variations on spelling, variation in the use of upper and lower case, typos, events that are abbreviated like TSTM, and events that should be the same but are not like Thunderstorm, THUNDERSTORM, TSTM WIND and THUNDERSTORMWIND. With all these variations there are 935 different factors

To start with I'll put everything in all caps, just eliminating lower case spelling cuts out 37 levels. There's also a list of 76 events that contain the word "SUMMARY", for example "SUMMARY AUGUST 11", that were incorrectly entered and don't indicate any particular weather type. I'm also going to convert and simplify all related event types. For example events that are similar to THUNDERSTORM, e.g. TSTM, THUNDERSTORM WIND G50, etc..., will become one event type "THUNDERSTORM". This next step performs all these weather type aggregations.

```{r, cache=TRUE}
StormData$EVTYPE <- as.character(StormData$EVTYPE)

StormData$EVTYPE <- toupper(StormData$EVTYPE)

StormData <- StormData[!grepl("SUMMARY", StormData$EVTYPE)]

StormData$EVTYPE[grepl("THU", StormData$EVTYPE) | grepl("TSTM", StormData$EVTYPE)] <- "THUNDERSTORM"

StormData$EVTYPE[grepl("SNOW", StormData$EVTYPE) ] <- "SNOW"

StormData$EVTYPE[grepl("FLOOD", StormData$EVTYPE) ] <- "FLOOD"

StormData$EVTYPE[grepl("VOLCANIC", StormData$EVTYPE) ] <- "VOLCANIC"

StormData$EVTYPE[grepl("TORN", StormData$EVTYPE) ] <- "TORNADO"

StormData$EVTYPE[grepl("LIGHTN", StormData$EVTYPE) | grepl("LIGHTING", StormData$EVTYPE) | grepl("LIGNTNING", StormData$EVTYPE) ] <- "LIGHTNING"

StormData$EVTYPE[grepl("RAIN", StormData$EVTYPE) ] <- "RAIN"

StormData$EVTYPE[grepl("FIRE", StormData$EVTYPE) ] <- "FIRE"

StormData$EVTYPE[grepl("TORN", StormData$EVTYPE) ] <- "TORNADO"

StormData$EVTYPE[grepl("HURRIC", StormData$EVTYPE) ] <- "HURRICANE"

StormData$EVTYPE[grepl("HAIL", StormData$EVTYPE) ] <- "HAIL"

StormData$EVTYPE[grepl("BLIZZARD", StormData$EVTYPE) ] <- "BLIZZARD"

StormData$EVTYPE[grepl("WINT", StormData$EVTYPE) ] <- "WINTER STORM"

StormData$EVTYPE[grepl("TROPICAL STORM", StormData$EVTYPE) ] <- "TROPICAL STORM"

StormData$EVTYPE[grepl("TROPICAL", StormData$EVTYPE) ] <- "TROPICAL STORM"

StormData$EVTYPE[grepl("ICE", StormData$EVTYPE) | grepl("GLAZE", StormData$EVTYPE) | grepl("ICY", StormData$EVTYPE) ] <- "ICE"

StormData$EVTYPE[grepl("FLOOD", StormData$EVTYPE) | grepl("FLDG", StormData$EVTYPE) | grepl("RAPIDLY RISING WATER", StormData$EVTYPE)] <- "FLOOD"

StormData$EVTYPE[grepl("MICROBURST", StormData$EVTYPE) ] <- "MICROBURST"

StormData$EVTYPE[grepl("HAIL", StormData$EVTYPE) ] <- "HAIL"

StormData$EVTYPE[grepl("WIND", StormData$EVTYPE) ] <- "WIND"

StormData$EVTYPE[grepl("WATERSP", StormData$EVTYPE) ] <- "WATERSPOUT"

StormData$EVTYPE[grepl("COOL", StormData$EVTYPE) | grepl("COLD", StormData$EVTYPE) | grepl("HYPOTHERM", StormData$EVTYPE)] <- "COLD"

StormData$EVTYPE[grepl("HOT", StormData$EVTYPE) | grepl("WARM", StormData$EVTYPE) | grepl("HEAT", StormData$EVTYPE) | grepl("HIGH TEMP", StormData$EVTYPE) | grepl("HYPERTHERMIA", StormData$EVTYPE)] <- "HEAT"

StormData$EVTYPE[grepl("HEAVY PR", StormData$EVTYPE) | grepl("HEAVY SH", StormData$EVTYPE)] <- "THUNDERSTORM"

StormData$EVTYPE[grepl("FREEZ", StormData$EVTYPE) ] <- "FREEZE"

StormData$EVTYPE[grepl("DUST", StormData$EVTYPE) ] <- "DUST"

StormData$EVTYPE[grepl("MUD", StormData$EVTYPE) ] <- "MUDSLIDE"

StormData$EVTYPE[grepl("STREAM", StormData$EVTYPE) ] <- "STREAM FLOOD"

StormData$EVTYPE[grepl("DRY", StormData$EVTYPE) ] <- "DRY"

StormData$EVTYPE[grepl("FUNNEL", StormData$EVTYPE) ] <- "FUNNEL CLOUD"

StormData$EVTYPE[grepl("WND", StormData$EVTYPE) ] <- "WIND"

StormData$EVTYPE[grepl("DAM", StormData$EVTYPE) ] <- "DAM FAILURE"

StormData$EVTYPE[grepl("RIP CURRENT", StormData$EVTYPE) ] <- "RIP CURRENT"

StormData$EVTYPE[grepl("HIGH SURF", StormData$EVTYPE) | grepl("HEAVY SURF", StormData$EVTYPE) | grepl("ROUGH SURF", StormData$EVTYPE) | grepl("HAZARDOUS SURF", StormData$EVTYPE)] <- "HEAVY SURF"

StormData$EVTYPE[grepl("STORM SURGE", StormData$EVTYPE) ] <- "STORM SURGE"

StormData$EVTYPE[grepl("COASTALSTORM", StormData$EVTYPE) ] <- "COASTAL STORM"

StormData$EVTYPE[grepl("AVALANC", StormData$EVTYPE) ] <- "AVALANCHE"

StormData$EVTYPE[grepl("HEAVY SEAS", StormData$EVTYPE) | grepl("ROUGH SEAS", StormData$EVTYPE)] <- "ROUGH SEAS"

StormData$EVTYPE[grepl("MARINE MISHAP", StormData$EVTYPE)] <- "MARINE ACCIDENT"

StormData$EVTYPE[grepl("SLEET", StormData$EVTYPE)] <- "SLEET"

StormData$EVTYPE[grepl("FOG", StormData$EVTYPE)] <- "FOG"

StormData$EVTYPE[grepl("SWELL", StormData$EVTYPE)] <- "HIGH SWELLS"

StormData$EVTYPE <- as.factor(as.character(StormData$EVTYPE))
```


<br>
Even after all that conversion there are still 117 different types of weather events, but the most significant ones should be aggregated into a few names key weather event types. 
```{r}
length(levels(StormData$EVTYPE))
```


<br>
 
To study the impact of storms on human health this analysis will look for storms that impact human health and storms that don't. 

The variables that indicate health impact are:
 
  - "FATALITIES" 
  - "INJURIES" 

<br>
To study the impact of storms on the economy this analysis will look for storms that damage property and storms that don't. 

The variables that indicate economic impact are:
 
  - "PROPDMG"    
  - "CROPDMG"   
  
Both "PROPDMG" and "CROPDMG" give dollar values of property or crop damage. There are two other variables,  "PROPDMGEXP" and "CROPDMGEXP", that give values indicating the order of magnitude of the damage, for example 'h' or 'H' indicates hundreds of dollars. Combining the two sets of values indicates how much damage there was. For example, a 1 in the PROPDMG column, plus "H" in the PROPDMGEXP column indicates a total of $100 of property damage. 2.5 plus "K" indicates $2,500 of damage. A full key of PROPDMGEXP values is included at the bottom of this document.

<br>

What I'm looking for is weather events that have a disproportionate impact on the economy or on health. As a hypothetical example, there may be a lot of thunderstorms with a lot of damage but each thunderstorm may have a low probability of injuring people or damaging property. In contrast, there may be many fewer tornadoes but each tornado may be disproportionately destructive. 

####Injuries and Fatalities

There were 21929 storm events that resulted in at least one injury or fatality
```{r}
sum(StormData$INJURIES > 0 | StormData$FATALITIES > 0)
```

```{r, cache=TRUE}
library(dplyr)

StormInjuriesFatalities <- filter(StormData, StormData$INJURIES > 0 | StormData$FATALITIES > 0)
dim(StormInjuriesFatalities)
```

I'm creating a new variable called WFI, or Weighted Fatalities and Injuries. This variable will combine injuries and fatalities into one variable and give more weight to fatalities. The formula is Fatalities * 10 + Injuries. 

```{r, cache=TRUE}
StormInjuriesFatalities$WFI <- sapply(StormInjuriesFatalities$FATALITIES, function(x) x*10) + StormInjuriesFatalities$INJURIES
```

Using tapply I'll aggregate the WFI variable by each storm event type.

```{r, cache=TRUE}
WFIbyEVTYPE <- tapply(StormInjuriesFatalities$WFI, StormInjuriesFatalities$EVTYPE, sum, na.rm=TRUE)
WFIbyEVTYPE <- data.table(EVTYPE = names(WFIbyEVTYPE), WFI = WFIbyEVTYPE)
```

There are a lot of weather event types that don't have any injuries or fatalities. This step eliminates all NA's in WFIbyEVTYPE
```{r, cache=TRUE}
WFIbyEVTYPE <- WFIbyEVTYPE[!is.na(WFIbyEVTYPE$WFI)]
```


```{r, cache=TRUE}
WFIbyEVTYPE <- arrange(WFIbyEVTYPE, desc(WFI))


for (i in 1: length(WFIbyEVTYPE$WFI)){
  WFIbyEVTYPE$NumberOfEvents[i] <- sum(StormData$EVTYPE == WFIbyEVTYPE$EVTYPE[i])
  WFIbyEVTYPE$WFIperEvent[i] <- WFIbyEVTYPE$WFI[i] / WFIbyEVTYPE$NumberOfEvents[i]
}

WFIbyEVTYPE <- WFIbyEVTYPE[WFIbyEVTYPE$NumberOfEvents >= 100]

```

Create two plots.
```{r, cache=TRUE}

WFIbyEVTYPE <- arrange(WFIbyEVTYPE, desc(WFI)) 
TopInjuriesFatalities <- WFIbyEVTYPE[1:10]
        
p1 <- ggplot(WFIbyEVTYPE[1:10], aes(EVTYPE, WFI))
p1 <- p1 + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 270, hjust=0))
p1 <- p1 + labs(title = "Weighted Fatalities and Injuries by Weather Event Type", x="", y="Weighted Fatalities and Injuries")
  

WFIbyEVTYPE <- arrange(WFIbyEVTYPE, desc(WFIperEvent)) 
MostLethalWeather <- WFIbyEVTYPE[1:10]


p2 <- ggplot(WFIbyEVTYPE[1:10], aes(EVTYPE, WFIperEvent))
p2 <- p2 + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 270, hjust = 0))
p2 <- p2 + labs(title = "Weighted Fatalities and Injuries by Weather Event Type\nDivided by the Total Number of Each Weather Event Type", x="", y="Weighted Fatalities and Injuries") + 
     theme(plot.title = element_text(hjust = 0.5))

```

Initialize the multiplot function.
```{r, cache=TRUE}

# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

```

And make the plots
```{r, fig.align='center', fig.height=8, fig.width=8, cache=TRUE}
multiplot(p1,p2, cols=1)
```


```{r}
TopInjuriesFatalities; MostLethalWeather
```


<br>
<br>

####Property and Crop Damage

There were 245031 weather events that resulted in some level of property or crop damage. First I'll make a new dataset called StormDamage that lists just those events.

```{r, cache=TRUE}
sum(StormData$PROPDMG > 0 | StormData$CROPDMG > 0)

StormDamage <- filter(StormData, StormData$PROPDMG > 0 | StormData$CROPDMG > 0)
dim(StormDamage)
```

```{r, cache=TRUE}

StormDamage$PROPDMGEXP <- as.character(StormDamage$PROPDMGEXP)
StormDamage$CROPDMGEXP <- as.character(StormDamage$CROPDMGEXP)

StormDamage$PROPDMGEXP <- toupper(StormDamage$PROPDMGEXP)
StormDamage$CROPDMGEXP <- toupper(StormDamage$CROPDMGEXP)

StormDamage$PROPDMGEXP[grepl("K", StormDamage$PROPDMGEXP)] <- "1000"
StormDamage$PROPDMGEXP[grepl("M", StormDamage$PROPDMGEXP)] <- "1000000"
StormDamage$PROPDMGEXP[grepl("H", StormDamage$PROPDMGEXP)] <- "100"
StormDamage$PROPDMGEXP[grepl("B", StormDamage$PROPDMGEXP)] <- "1000000000"


StormDamage$CROPDMGEXP[grepl("K", StormDamage$CROPDMGEXP)] <- "1000"
StormDamage$CROPDMGEXP[grepl("M", StormDamage$CROPDMGEXP)] <- "1000000"
StormDamage$CROPDMGEXP[grepl("H", StormDamage$CROPDMGEXP)] <- "100"
StormDamage$CROPDMGEXP[grepl("B", StormDamage$CROPDMGEXP)] <- "1000000000"


StormDamage$CROPDMGEXP<- as.numeric(StormDamage$CROPDMGEXP)
StormDamage$PROPDMGEXP<- as.numeric(StormDamage$PROPDMGEXP)




StormDamage$CROPDMGEXP[StormDamage$CROPDMGEXP == 0 & !is.na(StormDamage$CROPDMGEXP)] <- 1
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 1 & !is.na(StormDamage$PROPDMGEXP)] <- 10
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 2 & !is.na(StormDamage$PROPDMGEXP)] <- 100
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 3 & !is.na(StormDamage$PROPDMGEXP)] <- 1000
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 4 & !is.na(StormDamage$PROPDMGEXP)] <- 10000
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 5 & !is.na(StormDamage$PROPDMGEXP)] <- 100000
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 6 & !is.na(StormDamage$PROPDMGEXP)] <- 1000000
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 7 & !is.na(StormDamage$PROPDMGEXP)] <- 10000000
StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 8 & !is.na(StormDamage$PROPDMGEXP)] <- 100000000

StormDamage$PROPDMGEXP[StormDamage$PROPDMGEXP == 0 & !is.na(StormDamage$PROPDMGEXP)] <- 1

StormDamage$CROPDMG[is.na(StormDamage$CROPDMG)] <- 0
StormDamage$CROPDMGEXP[is.na(StormDamage$CROPDMGEXP)] <- 0
StormDamage$PROPDMG[is.na(StormDamage$PROPDMG)] <- 0  
StormDamage$PROPDMGEXP[is.na(StormDamage$PROPDMGEXP)] <- 0

StormDamage$CROPDMG <- StormDamage$CROPDMG * StormDamage$CROPDMGEXP
StormDamage$PROPDMG <- StormDamage$PROPDMG * StormDamage$PROPDMGEXP




StormDamage$TOTALDMG <- StormDamage$PROPDMG + StormDamage$CROPDMG


DamageByEvent<- tapply(StormDamage$TOTALDMG, StormDamage$EVTYPE, sum)
DamageByEvent<- data.table(EVTYPE = names(DamageByEvent), DAMAGE = DamageByEvent)
DamageByEvent<- DamageByEvent[!is.na(DamageByEvent$DAMAGE)]

DamageByEvent <- arrange(DamageByEvent, desc(DAMAGE))


p3 <- ggplot(DamageByEvent[1:15], aes(EVTYPE, DAMAGE))
p3 <- p3 + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 270, hjust=0))
p3 <- p3 + labs(title = "Crop and Property Damage By Weather Event Type", y="Dollars of Damage",       x="")



MostSevereEVTYPE<- DamageByEvent$EVTYPE[1:15]

HighestDamage <- StormDamage[StormDamage$EVTYPE %in% MostSevereEVTYPE]
HighestDamage$EVTYPE <- as.factor(as.character(HighestDamage$EVTYPE))



p5 <- qplot(EVTYPE, TOTALDMG, data=HighestDamage,na.rm = TRUE, geom="boxplot")
p5 <- p5 + scale_y_log10() + labs(title = "Crop and Property Damage By Weather Event Type", y="Dollars of Damage, Log Scale", x="") + theme(axis.text.x = element_text(angle = 270, hjust=0))

```




###Results

```{r, fig.align='center', fig.height=10, fig.width=8}
multiplot(p3,p5,cols=1)
```


	•	There should be a section titled Results in which your results are presented.
```{r}

```


```{r}

```

Your data analysis must address the following questions:
  1	Across the United States, which types of events (as indicated in the EVTYPE variable) 
    are most harmful with respect to population health?
  2	Across the United States, which types of events have the greatest economic consequences?
Consider writing your report as if it were to be read by a government or municipal manager who 
might be responsible for preparing for severe weather events and will need to prioritize resources 
for different types of events. However, there is no need to make any specific recommendations in your report




####**Document Layout**

	•	You may have other sections in your analysis, but Data Processing and Results are required.
	•	The analysis document must have at least one figure containing a plot.
	•	Your analyis must have no more than three figures. Figures may have multiple plots in them (i.e. panel plots), but there cannot be more than three figures total.
	•	You must show all your code for the work in your analysis document. This may make the document a bit verbose, but that is okay. In general, you should ensure that echo = TRUE for every code chunk (this is the default setting in knitr).
	
	
	
	
	
###Footnote

####These are possible values of CROPDMGEXP and PROPDMGEXP:

H,h,K,k,M,m,B,b,+,-,?,0,1,2,3,4,5,6,7,8, and blank-character

H,h = hundreds = 100

K,k = kilos = thousands = 1,000

M,m = millions = 1,000,000

B,b = billions = 1,000,000,000

(+) = 1

(-) = 0

(?) = 0

black/empty character = 0

numeric 0..8 = 10
	
	
	
	
	
	